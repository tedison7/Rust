# 10. 제네릭 타입, 트레이트 그리고 수명

제네릭을 활용하는 타입, 함수, 메서드를 직접 선언하는 방법을 살펴보자.

## 함수로부터 중복 제거하기

먼저 제네릭 타입을 사용하지 않고 함수로부터 중복된 코드를 제거하는 방법을 알아보자.

```rust
fn main() 
{
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("가장 큰 숫자: {}", largest);
}
```

두 개의 리스트에서 가장 큰 값을 찾으려면 위 예제를 복사하여 두번 실행 하면 된다. 이런 중복 코드를 없애려면 정수의 리스트를 매개변수로 전달받아 작업을 실행하는 함수를 정의하면 된다.

```rust
fn largest(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("가장 큰 숫자: {}", result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("가장 큰 숫자: {}", result);
}
```

다음으로는 i32 값들의 슬라이스로 부터 가장 큰 값을 찾는 코드와 char 값의 슬라이스로부터 가장 큰 값을 찾는 코드가 있다고 가정할 때 코드의 중복을 어떻게 제거할지 알아볼 것이다.

## 제네릭 데이터 타입

제네릭은 여러 구체화된 타입을 사용할 수 있는 함수 시그너처나 구조체 같은 아이템을 정의할 때 사용한다.

### 함수 정의에서 사용하기

```rust
fn largest_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &[char]) -> char {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&number_list);
    println!("가장 큰 숫자: {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&char_list);
    println!("가장 큰 문자: {}", result);
}
```

제네릭 타입으로 묶을 때 함수이름과 매개변수 목록 사이에 <T>를 사용하여 사용한다.

```rust
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("가장 큰 숫자: {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("가장 큰 문자: {}", result);
}
```

위 코드를 컴파일하면 에러가 발생한다.

[10_1 사진 첨부]

타입 T의 값을 비교하므로 이 값은 반드시 정렬 가능해야 한다. 표준 라이브러리는 비교 연산을 수행할 타입들은 std::cmp::PartialOrd 트레이트를 구현할 것을 요구한다.

### 구조체 정의에서 사용하기

구조체의 필드에도 <> 구문을 이용해 제네릭 타입 매개변수를 사용할 수 있다.

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

필드 x와 y는 모두 같은 타입이기 때문에 인스턴스를 생성할 때 서로 다른 타입의 값을 사용하면 컴파일되지 않는다.

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```

[10_2 사진 첨부]

다른 타입의 제네릭 데이터 타입으로 선언하고 싶다면 다중 제네릭 타입 매개변수를 사용하면 된다.

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```

### 열거자 정의에서 사용하기

```rust
enum Option<T> {
    Some(T),
    None,
}

enum Result<T,E> {
    Ok(T),
    Err(E),
}
```

Option<T>는 타입 T를 일반화한 열거자며, 두 개의 열것값을 가지고 있다. 해당 열거자를 사용하면 선택적인 값의 개념을 추상화할 수 있으며, 제네릭 열거자이므로 선택적인 값의 타입과 무관하게 추상화된 타입을 사용할 수 있다.
Result 열거자는 두 개의 타입 T와 E를 일반화한 타입이며 두 개의 열것값을 갖는다. Result 열거자는 작업이 성공적으로 실행된 경우와 실패한 경우를 모두 표현할 수 있다. 코드에서 여러개의 구조체나 열거자가 오직 저장하는 값의 타입만 다를 때는 제네릭 타입을 이용해 이런 중복을 제거할 수 있다.

### 메서드 정의에서 사용하기

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };
    
    println!("p.x = {}", p.x());
}
```

위 예제는 Point<T> 구조체에 필드 x의 데이터에 대한 참조를 리턴하는 메서드 x를 정의하고 있다. Point<T> 타입의 메서드를 구현한다는 점을 명시하기 위해 impl 키워드 바로 다음에 타입 매개변수 T를 지정했다는 점에 유의하자. impl 키워드 다음에 타입 T를 지정하면 러스트는 Point 구조체의 꺽쇠 괄호 안에 지정된 타입이 구체화된 타입이 아닌 제네릭 타입이라는 점을 인식한다.

```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

위 코드는 Point<f32> 특정 타입의 인스턴스에만 적용할 메서드를 구현한 것이다. 이때는 impl 키워드 뒤에 타입을 명시할 필요가 없다. 다른 Point<T> 인스턴스는 이 메서드를 사용할 수 없다.

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T,U> Point<T,U> {
    fn mixup<V,W> (self, other: Point<V,W>) -> Point<T,W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);
    println!("p3.x = {}. p3.y = {}", p3.x, p3.y);
}
```

위코드는 자신과 다른 구조체를 매개변수로 하여 혼합된 타입을 적용할수 있는 메서드를 구현한 것이다.

[10_3 사진 첨부]

### 제네릭의 성능

러스트가 제네릭을 구현하는 방식은 제네릭 타입을 사용한다고 해서 구체화된 타입을 사용할 떄보다 성능이 떨어지지 않는 다는 점이다. 컴파일 시점에 제네릭을 사용하는 코드를 단일화(Monomorphzation)하기 때문이다. 단일화는 컴파일 시점에 제네릭 코드를 실제로 사용하는 구체화된 타입으로 변환하는 과정이다. 이런 단일화 과정 덕분에 러스트의 제네릭은 런타임에 매우 효율적이다.

## 트레이트: 공유 가능한 행위를 정의 하는 방법

